#!/usr/bin/env python

from optparse import OptionParser
from datetime import datetime
from collections import deque
import pipes
import logging
import ConfigParser
import os
import pprint
import sys

ab_root      = os.path.join(os.environ['HOME'], '.autoburn/')
ab_conf_file = os.path.join(ab_root, 'conf')
ab_db_file   = os.path.join(ab_root, 'dvd_db.sql')
config       = None

def walkdsize(dir):
    tsum = 0
    for root, dirs, files in os.walk(dir):
        for name in files:
            try:
                tsum += os.path.getsize(os.path.join(root, name))
            except OSError:
                logging.warning("Can't access %s, skipping" \
                                % os.path.join(root, name))
    return tsum

class ConfigError(Exception):
    pass

class DvdEntry():
    def __init__(self, path):
        self.path = path
        self.ext = os.path.splitext(path)[1]
        if os.path.isdir(self.path):
            self.isdir = True
            self.size  = walkdsize(self.path)
        else:
            self.isdir = False
            self.size  = os.path.getsize(self.path)
        # Check if we're good, that is, check if we are a 'to burn' entry or not
        if self.size > Dvd.max_size():
            self.good = False
        elif self.size < config.getint('limits', 'min_fsize'):
            self.good = False
        elif self.ext == '.burned':
            self.good = False
        else:
            self.good = True
            
    def __cmp__(self, other):
        return cmp(self.size, other.size)
   
    def __str__(self):
        return "DvdEntry: {0} size: {1}".format(self.path, self.size)

class Dvd():
    def __init__(self):
        self.entries = deque()
        self.size = 0
        self.date = datetime.now().strftime("%d-%m-%y %H:%M")

    def __str__(self):
        s = '->DVD {0} {1} ({2}%)<-\n'.format(self.date, self.size, \
                                                  self.ratio())
        for e in self.entries:
            s += os.path.basename(e.path) + '\n'
            
        s += '-----------------------------------------'
        return s

    def __cmp__(self, other):
        return cmp(self.size, other.size)
    
    def __iter__(self):
        return iter(self.entries)
    
    def put(self, e):
        if (self.size + e.size) > self.max_size():
            return False
        
        self.entries.append(e)
        self.size += e.size
        return True

    def ratio(self):
        return int((self.size * 100) / \
            config.getfloat('limits', 'dvd_size'))

    def moveburned(self):
        for e in self.entries:
            oldname = pipes.quote(e.path)
            newname = pipes.quote(e.path + '.burned')
            cmdstr = 'mv -f {0} {1}'.format(oldname, newname)
            logging.debug('moveburned string: ' + cmdstr)
            os.system(cmdstr)

    def makeiso(self):
        if not config.has_option('main', 'isoname'):
            raise ConfigError("Missing isoname opttion")
        
        isopath = config.get('main', 'isoname')
        paths = ''
        for e in self.entries:
            paths += pipes.quote(e.path) + ' '
        
        cmdstr = 'mkisofs -o {0} -R -J -r -graft-points -A teste -V teste {1}'. \
            format(isopath, paths)
    
        logging.debug('mkisofs string: ' + cmdstr)

        if os.system(cmdstr) != 0:
            raise RuntimeError("mkisofs returned error")
        
    def burn(self):
        paths = ''
        for e in self.entries:
            paths += pipes.quote(e.path) + ' '
            
        cmdstr = 'growisofs -dvd-compat -Z {0} -V {1} -R -J -r -graft-points {2}'. \
            format(config.get('main', 'device'), pipes.quote(self.date), paths)
        logging.debug('burnstring = ' + cmdstr)
        
    @staticmethod
    def max_size():
        return int(config.getfloat('limits', 'max_dvd_ratio') \
                       * config.getint('limits', 'dvd_size'))

    
def query_yes_no(question, default="yes"):
    valid = {"yes":"yes",   "y":"yes",  "ye":"yes",
             "no":"no",     "n":"no"}
    if default == None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while 1:
       sys.stdout.write(question + prompt)
       choice = raw_input().lower()
       if default is not None and choice == '':
           return default
       elif choice in valid.keys():
           return valid[choice]
       else:
           sys.stdout.write("Please respond with 'yes' or 'no' "\
                                "(or 'y' or 'n').\n")

def checkbin(biname):
    if filter(lambda x: os.path.exists(os.path.join(x, biname)),
              os.environ['PATH'].split(':')):
        return True
    return False
           
def doconf():
    global config
   
    if not os.path.exists(ab_conf_file):
        raise ConfigError("No config file at %s" % ab_conf_file)

    config = ConfigParser.ConfigParser()
    config.read(ab_conf_file)
   
    for y in ['sources', 'mails']:
        l = config.get('main', y).split(',')
        l = map(lambda x: x.strip(), l)
        config.set('main', y, l)
    parser = OptionParser()
    parser.add_option('-b', '--dont-burn',
                      dest    = 'dontburn',
                      action  = 'store_true',
                      default = False,
                      help    = 'Don\'t burn a media')
    parser.add_option('-d', '--device',
                      dest    = 'device',
                      action  = 'store',
                      default = config.get('main', 'device'),
                      help    = 'Device to be used (/dev/sdX)')
    parser.add_option('-i', '--interactive',
                      dest    = 'interactive',
                      action  = 'store_false',
                      default = False,
                      help    = 'Interactive mode')
    parser.add_option('-o', '--iso-image',
                      dest    = 'isoname',
                      action  = 'store',
                      default = None,
                      help    = 'Output an iso image with given name')
    parser.add_option('-m', '--mail',
                      dest = 'mails',
                      action = 'append',
                      default = [],
                      help = 'Mail address to be notified')
    parser.add_option('-M', '--dont-move',
                      dest    = 'dontmove',
                      action  = 'store_true',
                      default = False,
                      help    = 'Don\'t move entries to .burned')
    parser.add_option('-s', '--source',
                      dest = 'sources',
                      action = 'append',
                      default = [],
                      help = 'Source directories to look for data')
    parser.add_option('-v', '--verbose',
                      dest    = 'verbose',
                      action  = 'count',
                      default = 1,
                      help    = 'Verbosity level')

    (options, args) = parser.parse_args()
   
    if args:
        raise ConfigError("Superfluous argument \'%s\'" % args[0])
   
    # Overwrite values
    if options.mails:
        config.set('main', 'mails', options.mails)
    if options.sources:
        config.set('main', 'sources', options.sources)
    if options.isoname:
        config.set('main', 'isoname', options.isoname)
    if options.dontburn:
        config.set('main', 'dontburn', 'true')
    if options.dontmove:
        config.set('main', 'dontmove', 'true')
    if options.interactive:
        config.set('main', 'interactive', 'true')

    
    # Main sanity check
    missing = [x for x in ['device', 'mails', 'sources', 'db'] \
                   if not config.get('main', x)]
    if missing:
        raise ConfigError("Missing config options in main section, %s" \
                              % str(missing))
      
    # Limits sanity check
    missing = [x for x in ['min_dvd_ratio', 'max_dvd_ratio', \
                               'min_fsize', 'dvd_size'] \
                   if not config.get('limits', x)]
    if missing:
        raise ConfigError("Missing config options in limits section, %s" \
                             % str(missing))

    # Verbosity
    if options.verbose == 1:
        logging.basicConfig(level = logging.WARNING)
    elif options.verbose == 2:
        logging.basicConfig(level = logging.INFO)
    else:
        logging.basicConfig(level = logging.DEBUG)
    
def main():
   if not checkbin('growisofs'):
       raise 'I can\'t find growisofs, check if you have it in PATH'
   if not checkbin('mkisofs'):
       raise 'I can\'t find mkisofs, check if you have it in PATH'
   
   check_conf()
   doconf()
   
   good    = []
   bad     = []
   dvdlist = []
   
   logging.debug('Considering sources {0}'. \
                     format(config.get('main', 'sources')))
   for src in config.get('main', 'sources'):
       for e in os.listdir(src):
           d = DvdEntry(os.path.join(src, e))
           if d.good:
               good.append(d)
           else:
               bad.append(d)
               
   logging.info("== Filtered out entries (bad) == ")
   for d in bad:
       logging.info(d)
       
   logging.debug("== In entries (good) == ")
   for d in good:
       logging.debug(d)

   dvd = Dvd()

   while good:
       e = good.pop()
       if dvd.put(e):
           continue
       # Won't fit anymore, get a new dvd
       dvdlist.append(dvd)
       if not good:
           break
       dvd = Dvd()
       
   dvdlist.sort()
   dvdlist.reverse()
   
   for d in dvdlist:
       print d
       
   if not dvdlist:
       sys.stdout.write("Could not assemble a single DVD")
       sys.exit(1)
   
   d = dvdlist.pop(0)
   
   if config.has_option('main', 'isoname'):
       d.makeiso()

   if config.has_option('main', 'dontburn'):
       logging.debug('Will not burn dvd')
   else:
       logging.debug('Will burn dvd')
       d.burn()
       
   # Move files to .burned
   if config.has_option('main', 'dontmove'):
       logging.debug('Will not move files to .burned')
   else:
       logging.debug('Will move files to .burned')
       d.moveburned()

   sys.exit(0)

def check_conf():
    if os.path.exists(ab_conf_file):
        return
    
    if not os.path.exists(ab_root):
        os.mkdir(ab_root)

    logging.warning('I can see this is the first time you are running me, created \
config file in {0}, tune the file for your needs'.format(ab_conf_file))

    cf = ConfigParser.ConfigParser()
    cf.add_section('main')
    cf.add_section('limits')
    cf.set('main', 'device', '/dev/rcd0c')
    cf.set('main', 'mails', 'foo@bar.com')
    cf.set('main', 'sources', os.environ['HOME'])
    cf.set('main', 'db', ab_db_file)
    cf.set('limits', 'min_dvd_ratio', 0.90)
    cf.set('limits', 'max_dvd_ratio', 0.96)
    cf.set('limits', 'min_fsize', 10000000)
    cf.set('limits', 'dvd_size', 4700000000)
    f = open(ab_conf_file, 'w')
    cf.write(f)
    f.close()
    
if __name__ == "__main__":
    main()
