#!/usr/bin/env python


# -d device
# default: probe
# -s source (multiplos)
# default home
# -m mail (multiplos)
# nao mandar
# -i iterativo?
# falso
# -r Don't record
# falso
# -w workdir
# $HOME/.autoburn/

from optparse import OptionParser
import logging
import ConfigParser
import os
import pprint
import sys

ab_root      = os.path.join(os.environ['HOME'], '.autoburn/')
ab_conf_file = os.path.join(ab_root, 'conf')
config       = None

def walkdsize(dir):
    tsum = 0
    for root, dirs, files in os.walk(dir):
        for name in files:
            try:
                tsum += os.path.getsize(os.path.join(root, name))
            except OSError:
                logging.warning("Can't access %s, skipping" \
                                % os.path.join(root, name))
    return tsum

class ConfigError(Exception):
    pass

class DvdEntry():
    def __init__(self, path):
        self.path = path
        if os.path.isdir(self.path):
            self.isdir = True
            self.size  = walkdsize(self.path)
        else:
            self.isdir = False
            self.size  = os.path.getsize(self.path)
         
    def __cmp__(self, other):
        return cmp(self.size, other.size)
   
    def __str__(self):
        return "DvdEntry: {0} size: {1}".format(self.path, self.size)
      
def query_yes_no(question, default="yes"):
    valid = {"yes":"yes",   "y":"yes",  "ye":"yes",
             "no":"no",     "n":"no"}
    if default == None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while 1:
       sys.stdout.write(question + prompt)
       choice = raw_input().lower()
       if default is not None and choice == '':
           return default
       elif choice in valid.keys():
           return valid[choice]
       else:
           sys.stdout.write("Please respond with 'yes' or 'no' "\
                                "(or 'y' or 'n').\n")

def checkbin(biname):
    if filter(lambda x: os.path.exists(os.path.join(x, biname)),
              os.environ['PATH'].split(':')):
        return True
    return False
           
def doconf():
    global config
   
    if not os.path.exists(ab_conf_file):
        raise ConfigError("No config file at %s" % ab_conf_file)

    config = ConfigParser.ConfigParser()
    config.read(ab_conf_file)
   
    for y in ['sources', 'mails']:
        l = config.get('main', y).split(',')
        l = map(lambda x: x.strip(), l)
        config.set('main', y, l)
    parser = OptionParser()
    parser.add_option('-d', '--device',
                      dest    = 'device',
                      action  = 'store',
                      default = config.get('main', 'device'),
                      help    = 'Device to be used (/dev/sdX)')
    parser.add_option('-i', '--interactive',
                      dest    = 'interactive',
                      action  = 'store_false',
                      default = False,
                      help    = 'Interactive mode')
    parser.add_option('-m', '--mail',
                      dest = 'mails',
                      action = 'append',
                      default = [],
                      help = 'Mail address to be notified')
    parser.add_option('-s', '--source',
                      dest = 'sources',
                      action = 'append',
                      default = [],
                      help = 'Source directories to look for data')
    parser.add_option('-v', '--verbose',
                      dest    = 'verbose',
                      action  = 'count',
                      default = 1,
                      help    = 'Verbosity level')
    parser.add_option('-w', '--workdir',
                      dest = 'workdir',
                      action = 'store',
                      default = None,
                      help = 'Source directory for temporary files')

    (options, args) = parser.parse_args()
   
    if args:
        raise ConfigError("Superfluous argument \'%s\'" % args[0])
   
    # Overwrite values
    if options.mails:
        config.set('main', 'mails', options.mails)
    if options.sources:
        config.set('main', 'sources', options.sources)

    # Main sanity check
    missing = [x for x in ['device', 'mails', 'workdir', 'sources', 'db'] \
                   if not config.get('main', x)]
    if missing:
        raise ConfigError("Missing config files in main section, %s" \
                              % str(missing))
      
    # Limits sanity check
    missing = [x for x in ['min_dvd_ratio', 'max_dvd_ratio', \
                               'min_fsize', 'dvd_size'] \
                   if not config.get('limits', x)]
    if missing:
        raise ConfigError("Missing config files in limits section, %s" \
                             % str(missing))

    # Verbosity
    if options.verbose == 1:
        logging.basicConfig(level = logging.WARNING)
    elif options.verbose == 2:
        logging.basicConfig(level = logging.INFO)
    else:
        logging.basicConfig(level = logging.DEBUG)

def main():
   if not checkbin('growisofs'):
       raise 'I can\'t find growisofs, check if you have it in PATH'
   doconf()
   
   entries = []
   
   logging.debug('Considering sources {0}'. \
                     format(config.get('main', 'sources')))
   for src in config.get('main', 'sources'):
       for e in os.listdir(src):
           logging.debug('Computing sub-source {0}'.format(e))
           entries.append(DvdEntry(os.path.join(src, e)))
   
if __name__ == "__main__":
    main()
